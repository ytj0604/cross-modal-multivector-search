#ifndef MULTI_VECTOR_RERANKER_H
#define MULTI_VECTOR_RERANKER_H
#define EIGEN_USE_BLAS

#include <Eigen/Dense>
#include <chrono>
#include <cstdint>
#include <fstream>
#include <functional>
#include <iostream>
#include <memory>
#include <unordered_set>
#include <vector>

using VectorSetID = unsigned int;
using VectorID = unsigned int;
using Cardinality = unsigned int;
using Matrix =
    Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;
using FloatVectorPtr = std::shared_ptr<std::vector<std::vector<float>>>;
using SetGroundTruthVectorPtr =
    std::shared_ptr<std::vector<std::vector<VectorSetID>>>;
using VectorGroundTruthVectorPtr =
    std::shared_ptr<std::vector<std::vector<VectorID>>>;
using VID2VSIDMapping = std::function<VectorSetID(VectorID)>;
using VSID2VIDMapping =
    std::function<std::pair<VectorID, Cardinality>(VectorSetID)>;
using GroundTruthMapping =
    std::function<std::pair<VectorSetID, Cardinality>(VectorSetID)>;

class MultiVectorReranker {
 public:
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  void SetVectorID2VectorSetIDMapping(std::function<VectorSetID(VectorID)> f);
  void SetMultiVectorCardinality(uint32_t cardinality);
  void SetDistanceMetric(const std::string& set_to_set_metric,
                         const std::string& vector_dist_metric);
  void SetDataVector(const Matrix& data_matrix);
  void SetQueryVector(const Matrix& query_matrix);
  void SetK(uint32_t k) { this->k = k; }
  template <typename IDType>
  void Rerank(VectorSetID& query_id,
              const std::vector<std::vector<IDType>>& indices,
              std::vector<VectorSetID>& reranked_indices);
  void RerankAllBySequentialScan(VectorSetID& query_id,
                                 std::vector<VectorSetID>& reranked_indices);
  void RerankAllAndGenerateSetGroundTruth(const std::string& ground_truth_file);

 private:
  void computeCosineSimilarity(const Eigen::Ref<const Matrix>&,
                               const Eigen::Ref<const Matrix>&,
                               Eigen::Ref<Matrix>);
  float computeSmoothChamferDistance(const Eigen::Ref<const Matrix>& img_embs,
                                     const Eigen::Ref<const Matrix>& txt_embs);
  float ComputeSummedMaxSimilarity(const Eigen::Ref<const Matrix>& img_embs,
                                   const Eigen::Ref<const Matrix>& txt_embs);
  uint32_t multi_vector_cardinality = 0;
  VID2VSIDMapping vector_id_to_vector_set_id = nullptr;
  VSID2VIDMapping vector_set_id_to_vector_id = nullptr;
  Matrix data_matrix;
  Matrix query_matrix;
  std::function<float(const Eigen::Ref<const Matrix>&,
                      const Eigen::Ref<const Matrix>&)>
      set_to_set_distance_metric;
  std::function<void(const Eigen::Ref<const Matrix>&,
                     const Eigen::Ref<const Matrix>&, Eigen::Ref<Matrix>)>
      vector_distance_metric;
  // Smooth-Chamfer distance parameters
  float temperature = 16.0f;
  float temperature_txt_scale = 1.0;
  float denominator = 2;
  uint32_t k;
};

class RecallCalculator {
 public:
  void SetK(uint32_t k) { this->k = k; }
  void SetGroundTruth(SetGroundTruthVectorPtr ground_truth);
  void SetPairedGroundTruth(GroundTruthMapping f) { paired_ground_truth = f; }
  double ComputeRecall(VectorSetID query_id,
                       const std::vector<VectorSetID>& reranked_indices);
  double ComputePairedRecall(VectorSetID query_id,
                             const std::vector<VectorSetID>&
                             reranked_indices);

 private:
  uint32_t k = 0;
  SetGroundTruthVectorPtr ground_truth = nullptr;
  GroundTruthMapping paired_ground_truth = nullptr;
};

class Loader {
 public:
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  static Matrix LoadEmbeddingVector(const std::string& file_path);
  static FloatVectorPtr LoadEmbeddingVectorAsFloatVector(
      const std::string& file_path);
  // Loads a set-level ground truth file
  static SetGroundTruthVectorPtr LoadGroundTruth(const std::string& file_path);
  // Loads a vector-level ground truth file (generated by the RoarGraph using
  // DiskANN's code)
  static VectorGroundTruthVectorPtr LoadVectorGroundTruth(
      const std::string& file_path);
  // Should be used for re-ranking.
  static std::pair<std::function<VectorSetID(VectorID)>,
                   std::function<std::pair<VectorID, Cardinality>(VectorSetID)>>
  LoadVectorCardinalityMappingAndGetBothMappings(std::string& file_path);
  static GroundTruthMapping LoadQueryDataPairMappingAsFunction(
      std::string& file_path);
};
#endif  // MULTI_VECTOR_RERANKER_H